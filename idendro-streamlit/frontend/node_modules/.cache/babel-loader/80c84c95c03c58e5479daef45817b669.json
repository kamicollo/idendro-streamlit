{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\n\nconst wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\n\nfunction pd(event) {\n  const retv = privateData.get(event);\n  console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\n\n\nfunction setCancelFlag(data) {\n  if (data.passiveListener != null) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n    }\n\n    return;\n  }\n\n  if (!data.event.cancelable) {\n    return;\n  }\n\n  data.canceled = true;\n\n  if (typeof data.event.preventDefault === \"function\") {\n    data.event.preventDefault();\n  }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\n\n\nfunction Event(eventTarget, event) {\n  privateData.set(this, {\n    eventTarget,\n    event,\n    eventPhase: 2,\n    currentTarget: eventTarget,\n    canceled: false,\n    stopped: false,\n    immediateStopped: false,\n    passiveListener: null,\n    timeStamp: event.timeStamp || Date.now()\n  }); // https://heycam.github.io/webidl/#Unforgeable\n\n  Object.defineProperty(this, \"isTrusted\", {\n    value: false,\n    enumerable: true\n  }); // Define accessors\n\n  const keys = Object.keys(event);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in this)) {\n      Object.defineProperty(this, key, defineRedirectDescriptor(key));\n    }\n  }\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEvent.prototype = {\n  /**\n   * The type of this event.\n   * @type {string}\n   */\n  get type() {\n    return pd(this).event.type;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get target() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    return pd(this).currentTarget;\n  },\n\n  /**\n   * @returns {EventTarget[]} The composed path of this event.\n   */\n  composedPath() {\n    const currentTarget = pd(this).currentTarget;\n\n    if (currentTarget == null) {\n      return [];\n    }\n\n    return [currentTarget];\n  },\n\n  /**\n   * Constant of NONE.\n   * @type {number}\n   */\n  get NONE() {\n    return 0;\n  },\n\n  /**\n   * Constant of CAPTURING_PHASE.\n   * @type {number}\n   */\n  get CAPTURING_PHASE() {\n    return 1;\n  },\n\n  /**\n   * Constant of AT_TARGET.\n   * @type {number}\n   */\n  get AT_TARGET() {\n    return 2;\n  },\n\n  /**\n   * Constant of BUBBLING_PHASE.\n   * @type {number}\n   */\n  get BUBBLING_PHASE() {\n    return 3;\n  },\n\n  /**\n   * The target of this event.\n   * @type {number}\n   */\n  get eventPhase() {\n    return pd(this).eventPhase;\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopPropagation() {\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.stopPropagation === \"function\") {\n      data.event.stopPropagation();\n    }\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopImmediatePropagation() {\n    const data = pd(this);\n    data.stopped = true;\n    data.immediateStopped = true;\n\n    if (typeof data.event.stopImmediatePropagation === \"function\") {\n      data.event.stopImmediatePropagation();\n    }\n  },\n\n  /**\n   * The flag to be bubbling.\n   * @type {boolean}\n   */\n  get bubbles() {\n    return Boolean(pd(this).event.bubbles);\n  },\n\n  /**\n   * The flag to be cancelable.\n   * @type {boolean}\n   */\n  get cancelable() {\n    return Boolean(pd(this).event.cancelable);\n  },\n\n  /**\n   * Cancel this event.\n   * @returns {void}\n   */\n  preventDefault() {\n    setCancelFlag(pd(this));\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    return pd(this).canceled;\n  },\n\n  /**\n   * The flag to be composed.\n   * @type {boolean}\n   */\n  get composed() {\n    return Boolean(pd(this).event.composed);\n  },\n\n  /**\n   * The unix time of this event.\n   * @type {number}\n   */\n  get timeStamp() {\n    return pd(this).timeStamp;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   * @deprecated\n   */\n  get srcElement() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The flag to stop event bubbling.\n   * @type {boolean}\n   * @deprecated\n   */\n  get cancelBubble() {\n    return pd(this).stopped;\n  },\n\n  set cancelBubble(value) {\n    if (!value) {\n      return;\n    }\n\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.cancelBubble === \"boolean\") {\n      data.event.cancelBubble = true;\n    }\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   * @deprecated\n   */\n  get returnValue() {\n    return !pd(this).canceled;\n  },\n\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag(pd(this));\n    }\n  },\n\n  /**\n   * Initialize this event object. But do nothing under event dispatching.\n   * @param {string} type The event type.\n   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n   * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n   * @deprecated\n   */\n  initEvent() {// Do nothing.\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(Event.prototype, \"constructor\", {\n  value: Event,\n  configurable: true,\n  writable: true\n}); // Ensure `event instanceof window.Event` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, window.Event.prototype); // Make association for wrappers.\n\n  wrappers.set(window.Event.prototype, Event);\n}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\n\n\nfunction defineRedirectDescriptor(key) {\n  return {\n    get() {\n      return pd(this).event[key];\n    },\n\n    set(value) {\n      pd(this).event[key] = value;\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\n\n\nfunction defineCallDescriptor(key) {\n  return {\n    value() {\n      const event = pd(this).event;\n      return event[key].apply(event, arguments);\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\n\n\nfunction defineWrapper(BaseEvent, proto) {\n  const keys = Object.keys(proto);\n\n  if (keys.length === 0) {\n    return BaseEvent;\n  }\n  /** CustomEvent */\n\n\n  function CustomEvent(eventTarget, event) {\n    BaseEvent.call(this, eventTarget, event);\n  }\n\n  CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n    constructor: {\n      value: CustomEvent,\n      configurable: true,\n      writable: true\n    }\n  }); // Define accessors.\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in BaseEvent.prototype)) {\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n      const isFunc = typeof descriptor.value === \"function\";\n      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n    }\n  }\n\n  return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\n\n\nfunction getWrapper(proto) {\n  if (proto == null || proto === Object.prototype) {\n    return Event;\n  }\n\n  let wrapper = wrappers.get(proto);\n\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n    wrappers.set(proto, wrapper);\n  }\n\n  return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\n\n\nfunction wrapEvent(eventTarget, event) {\n  const Wrapper = getWrapper(Object.getPrototypeOf(event));\n  return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\n\n\nfunction isStopped(event) {\n  return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\n\n\nfunction setEventPhase(event, eventPhase) {\n  pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\n\n\nfunction setCurrentTarget(event, currentTarget) {\n  pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\n\n\nfunction setPassiveListener(event, passiveListener) {\n  pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\n\n\nconst listenersMap = new WeakMap(); // Listener types\n\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\n\nfunction isObject(x) {\n  return x !== null && typeof x === \"object\"; //eslint-disable-line no-restricted-syntax\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\n\n\nfunction getListeners(eventTarget) {\n  const listeners = listenersMap.get(eventTarget);\n\n  if (listeners == null) {\n    throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n  }\n\n  return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\n\n\nfunction defineEventAttributeDescriptor(eventName) {\n  return {\n    get() {\n      const listeners = getListeners(this);\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          return node.listener;\n        }\n\n        node = node.next;\n      }\n\n      return null;\n    },\n\n    set(listener) {\n      if (typeof listener !== \"function\" && !isObject(listener)) {\n        listener = null; // eslint-disable-line no-param-reassign\n      }\n\n      const listeners = getListeners(this); // Traverse to the tail while removing old value.\n\n      let prev = null;\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          // Remove old value.\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners.delete(eventName);\n          }\n        } else {\n          prev = node;\n        }\n\n        node = node.next;\n      } // Add new value.\n\n\n      if (listener !== null) {\n        const newNode = {\n          listener,\n          listenerType: ATTRIBUTE,\n          passive: false,\n          once: false,\n          next: null\n        };\n\n        if (prev === null) {\n          listeners.set(eventName, newNode);\n        } else {\n          prev.next = newNode;\n        }\n      }\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\n\n\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\n\n\nfunction defineCustomEventTarget(eventNames) {\n  /** CustomEventTarget */\n  function CustomEventTarget() {\n    EventTarget.call(this);\n  }\n\n  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n    constructor: {\n      value: CustomEventTarget,\n      configurable: true,\n      writable: true\n    }\n  });\n\n  for (let i = 0; i < eventNames.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n  }\n\n  return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\n\n\nfunction EventTarget() {\n  /*eslint-disable consistent-return */\n  if (this instanceof EventTarget) {\n    listenersMap.set(this, new Map());\n    return;\n  }\n\n  if (arguments.length === 1 && Array.isArray(arguments[0])) {\n    return defineCustomEventTarget(arguments[0]);\n  }\n\n  if (arguments.length > 0) {\n    const types = new Array(arguments.length);\n\n    for (let i = 0; i < arguments.length; ++i) {\n      types[i] = arguments[i];\n    }\n\n    return defineCustomEventTarget(types);\n  }\n\n  throw new TypeError(\"Cannot call a class as a function\");\n  /*eslint-enable consistent-return */\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEventTarget.prototype = {\n  /**\n   * Add a given listener to this event target.\n   * @param {string} eventName The event name to add.\n   * @param {Function} listener The listener to add.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  addEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    if (typeof listener !== \"function\" && !isObject(listener)) {\n      throw new TypeError(\"'listener' should be a function or an object.\");\n    }\n\n    const listeners = getListeners(this);\n    const optionsIsObj = isObject(options);\n    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    const newNode = {\n      listener,\n      listenerType,\n      passive: optionsIsObj && Boolean(options.passive),\n      once: optionsIsObj && Boolean(options.once),\n      next: null\n    }; // Set it as the first node if the first node is null.\n\n    let node = listeners.get(eventName);\n\n    if (node === undefined) {\n      listeners.set(eventName, newNode);\n      return;\n    } // Traverse to the tail while checking duplication..\n\n\n    let prev = null;\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        // Should ignore duplication.\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    } // Add it.\n\n\n    prev.next = newNode;\n  },\n\n  /**\n   * Remove a given listener from this event target.\n   * @param {string} eventName The event name to remove.\n   * @param {Function} listener The listener to remove.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  removeEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    const listeners = getListeners(this);\n    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    let prev = null;\n    let node = listeners.get(eventName);\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    }\n  },\n\n  /**\n   * Dispatch a given event.\n   * @param {Event|{type:string}} event The event to dispatch.\n   * @returns {boolean} `false` if canceled.\n   */\n  dispatchEvent(event) {\n    if (event == null || typeof event.type !== \"string\") {\n      throw new TypeError('\"event.type\" should be a string.');\n    } // If listeners aren't registered, terminate.\n\n\n    const listeners = getListeners(this);\n    const eventName = event.type;\n    let node = listeners.get(eventName);\n\n    if (node == null) {\n      return true;\n    } // Since we cannot rewrite several properties, so wrap object.\n\n\n    const wrappedEvent = wrapEvent(this, event); // This doesn't process capturing phase and bubbling phase.\n    // This isn't participating in a tree.\n\n    let prev = null;\n\n    while (node != null) {\n      // Remove this listener if it's once\n      if (node.once) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n      } else {\n        prev = node;\n      } // Call this listener\n\n\n      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n\n      if (typeof node.listener === \"function\") {\n        try {\n          node.listener.call(this, wrappedEvent);\n        } catch (err) {\n          if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(err);\n          }\n        }\n      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n        node.listener.handleEvent(wrappedEvent);\n      } // Break if `event.stopImmediatePropagation` was called.\n\n\n      if (isStopped(wrappedEvent)) {\n        break;\n      }\n\n      node = node.next;\n    }\n\n    setPassiveListener(wrappedEvent, null);\n    setEventPhase(wrappedEvent, 0);\n    setCurrentTarget(wrappedEvent, null);\n    return !wrappedEvent.defaultPrevented;\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n  value: EventTarget,\n  configurable: true,\n  writable: true\n}); // Ensure `eventTarget instanceof window.EventTarget` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };","map":{"version":3,"sources":["../src/event.mjs","../src/event-target.mjs"],"names":[],"mappings":"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","sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"]},"metadata":{},"sourceType":"module"}